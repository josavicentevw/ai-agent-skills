# Vulnerability Management Workflow

Complete vulnerability management process from detection to remediation with automated workflows.

## üìù Prompt

```
Create a comprehensive vulnerability management system:

Context:
- Multi-cloud environment (AWS, Azure)
- Microservices architecture
- CI/CD pipelines with GitHub Actions
- Production systems with SLA requirements
- Compliance requirements (SOC 2, ISO 27001)

Include:
- Vulnerability detection and scanning
- Severity assessment and prioritization
- Automated ticketing and assignment
- Remediation tracking workflows
- SLA management and escalation
- Reporting and metrics
- Integration with security tools
- Continuous monitoring
- Compliance reporting

Provide production-ready implementation with automation.
```

## üîç Vulnerability Detection

### 1. Continuous Scanning Pipeline

**File:** `.github/workflows/vulnerability-scan.yml`

```yaml
name: Vulnerability Detection

on:
  schedule:
    - cron: '0 */6 * * *' # Every 6 hours
  push:
    branches: [main, develop]
  pull_request:
  workflow_dispatch:

env:
  SEVERITY_CRITICAL: 'CRITICAL'
  SEVERITY_HIGH: 'HIGH'
  SEVERITY_MEDIUM: 'MEDIUM'
  SEVERITY_LOW: 'LOW'

jobs:
  # ===== DEPENDENCY SCANNING =====
  dependency-scan:
    name: Scan Dependencies
    runs-on: ubuntu-latest
    outputs:
      critical: ${{ steps.analyze.outputs.critical }}
      high: ${{ steps.analyze.outputs.high }}
      medium: ${{ steps.analyze.outputs.medium }}
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Snyk test
        id: snyk
        continue-on-error: true
        uses: snyk/actions/node@master
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        with:
          args: --severity-threshold=low --json-file-output=snyk-results.json

      - name: Analyze results
        id: analyze
        run: |
          CRITICAL=$(jq '[.vulnerabilities[] | select(.severity == "critical")] | length' snyk-results.json)
          HIGH=$(jq '[.vulnerabilities[] | select(.severity == "high")] | length' snyk-results.json)
          MEDIUM=$(jq '[.vulnerabilities[] | select(.severity == "medium")] | length' snyk-results.json)
          
          echo "critical=$CRITICAL" >> $GITHUB_OUTPUT
          echo "high=$HIGH" >> $GITHUB_OUTPUT
          echo "medium=$MEDIUM" >> $GITHUB_OUTPUT
          
          echo "üìä Vulnerability Summary:"
          echo "   Critical: $CRITICAL"
          echo "   High: $HIGH"
          echo "   Medium: $MEDIUM"

      - name: Upload results
        uses: actions/upload-artifact@v4
        with:
          name: dependency-scan-results
          path: snyk-results.json

  # ===== CONTAINER SCANNING =====
  container-scan:
    name: Scan Container Images
    runs-on: ubuntu-latest
    outputs:
      critical: ${{ steps.analyze.outputs.critical }}
      high: ${{ steps.analyze.outputs.high }}
    steps:
      - uses: actions/checkout@v4

      - name: Build image
        run: docker build -t ${{ github.repository }}:${{ github.sha }} .

      - name: Run Trivy scanner
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: '${{ github.repository }}:${{ github.sha }}'
          format: 'json'
          output: 'trivy-results.json'

      - name: Analyze results
        id: analyze
        run: |
          CRITICAL=$(jq '[.Results[].Vulnerabilities[]? | select(.Severity == "CRITICAL")] | length' trivy-results.json)
          HIGH=$(jq '[.Results[].Vulnerabilities[]? | select(.Severity == "HIGH")] | length' trivy-results.json)
          
          echo "critical=$CRITICAL" >> $GITHUB_OUTPUT
          echo "high=$HIGH" >> $GITHUB_OUTPUT

      - name: Upload results
        uses: actions/upload-artifact@v4
        with:
          name: container-scan-results
          path: trivy-results.json

  # ===== CODE SCANNING =====
  code-scan:
    name: Scan Source Code
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: CodeQL scan
        uses: github/codeql-action/init@v3
        with:
          languages: javascript, typescript

      - name: Perform CodeQL Analysis
        uses: github/codeql-action/analyze@v3

      - name: Semgrep scan
        uses: returntocorp/semgrep-action@v1
        with:
          config: >-
            p/security-audit
            p/owasp-top-ten
          generateSarif: true

  # ===== CREATE VULNERABILITY TICKETS =====
  create-tickets:
    name: Create Vulnerability Tickets
    runs-on: ubuntu-latest
    needs: [dependency-scan, container-scan]
    if: needs.dependency-scan.outputs.critical > 0 || needs.container-scan.outputs.critical > 0
    steps:
      - uses: actions/checkout@v4

      - name: Download scan results
        uses: actions/download-artifact@v4

      - name: Process vulnerabilities
        id: process
        run: |
          python3 scripts/process-vulnerabilities.py \
            --dependency-results dependency-scan-results/snyk-results.json \
            --container-results container-scan-results/trivy-results.json \
            --output vulnerabilities.json

      - name: Create Jira tickets
        uses: atlassian/gajira-create@v3
        with:
          project: SEC
          issuetype: Bug
          summary: '[VULN] ${{ steps.process.outputs.title }}'
          description: ${{ steps.process.outputs.description }}
          fields: |
            {
              "priority": {"name": "${{ steps.process.outputs.priority }}"},
              "labels": ["security", "vulnerability", "automated"],
              "customfield_10001": "${{ steps.process.outputs.severity }}"
            }
        env:
          JIRA_BASE_URL: ${{ secrets.JIRA_BASE_URL }}
          JIRA_USER_EMAIL: ${{ secrets.JIRA_USER_EMAIL }}
          JIRA_API_TOKEN: ${{ secrets.JIRA_API_TOKEN }}

      - name: Create GitHub issues
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const vulns = JSON.parse(fs.readFileSync('vulnerabilities.json'));
            
            for (const vuln of vulns.critical) {
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: `üö® [CRITICAL] ${vuln.title}`,
                body: `## Vulnerability Details\n\n${vuln.description}\n\n**Severity:** CRITICAL\n**CVE:** ${vuln.cve}\n**Package:** ${vuln.package}\n**Fix:** ${vuln.fix}`,
                labels: ['security', 'critical', 'vulnerability']
              });
            }

      - name: Notify security team
        uses: 8398a7/action-slack@v3
        with:
          status: custom
          custom_payload: |
            {
              text: 'üö® Critical vulnerabilities detected!',
              attachments: [{
                color: 'danger',
                text: `Critical: ${{ needs.dependency-scan.outputs.critical }}\nHigh: ${{ needs.dependency-scan.outputs.high }}\n\nAction required: Review and remediate immediately.`
              }]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_SECURITY_WEBHOOK }}
```

---

## üéØ Vulnerability Processing Script

**File:** `scripts/process-vulnerabilities.py`

```python
#!/usr/bin/env python3
import json
import argparse
from datetime import datetime, timedelta
from typing import List, Dict
import hashlib

class VulnerabilityProcessor:
    # SLA times in hours
    SLA_CRITICAL = 24
    SLA_HIGH = 72
    SLA_MEDIUM = 168  # 1 week
    SLA_LOW = 720     # 30 days
    
    def __init__(self, dependency_file, container_file, output_file):
        self.dependency_file = dependency_file
        self.container_file = container_file
        self.output_file = output_file
        self.vulnerabilities = {
            'critical': [],
            'high': [],
            'medium': [],
            'low': []
        }
    
    def process(self):
        """Process all vulnerability sources"""
        self.process_dependencies()
        self.process_containers()
        self.deduplicate()
        self.prioritize()
        self.calculate_sla()
        self.save_results()
        self.print_summary()
    
    def process_dependencies(self):
        """Process Snyk dependency scan results"""
        try:
            with open(self.dependency_file, 'r') as f:
                data = json.load(f)
            
            for vuln in data.get('vulnerabilities', []):
                severity = vuln['severity'].lower()
                
                processed = {
                    'id': self.generate_id(vuln),
                    'type': 'dependency',
                    'title': vuln.get('title', 'Unknown vulnerability'),
                    'severity': severity,
                    'cvss_score': vuln.get('cvssScore', 0),
                    'cve': vuln.get('identifiers', {}).get('CVE', ['N/A'])[0],
                    'cwe': vuln.get('identifiers', {}).get('CWE', ['N/A']),
                    'package': vuln.get('packageName', 'unknown'),
                    'version': vuln.get('version', 'unknown'),
                    'fixed_version': vuln.get('fixedIn', ['Not available'])[0],
                    'description': vuln.get('description', ''),
                    'exploit': vuln.get('exploit', 'Not known'),
                    'patch_available': bool(vuln.get('fixedIn')),
                    'references': vuln.get('references', []),
                    'detected_at': datetime.now().isoformat()
                }
                
                if severity in self.vulnerabilities:
                    self.vulnerabilities[severity].append(processed)
        
        except FileNotFoundError:
            print(f"‚ö†Ô∏è  Dependency file not found: {self.dependency_file}")
    
    def process_containers(self):
        """Process Trivy container scan results"""
        try:
            with open(self.container_file, 'r') as f:
                data = json.load(f)
            
            for result in data.get('Results', []):
                for vuln in result.get('Vulnerabilities', []):
                    severity = vuln['Severity'].lower()
                    
                    processed = {
                        'id': self.generate_id(vuln),
                        'type': 'container',
                        'title': vuln.get('Title', f"Vulnerability in {vuln.get('PkgName')}"),
                        'severity': severity,
                        'cvss_score': self.extract_cvss(vuln),
                        'cve': vuln.get('VulnerabilityID', 'N/A'),
                        'cwe': [vuln.get('CweIDs', 'N/A')],
                        'package': vuln.get('PkgName', 'unknown'),
                        'version': vuln.get('InstalledVersion', 'unknown'),
                        'fixed_version': vuln.get('FixedVersion', 'Not available'),
                        'description': vuln.get('Description', ''),
                        'exploit': 'Not known',
                        'patch_available': bool(vuln.get('FixedVersion')),
                        'references': vuln.get('References', []),
                        'detected_at': datetime.now().isoformat()
                    }
                    
                    if severity in self.vulnerabilities:
                        self.vulnerabilities[severity].append(processed)
        
        except FileNotFoundError:
            print(f"‚ö†Ô∏è  Container file not found: {self.container_file}")
    
    def generate_id(self, vuln: Dict) -> str:
        """Generate unique ID for vulnerability"""
        key = f"{vuln.get('packageName', vuln.get('PkgName', 'unknown'))}:{vuln.get('version', vuln.get('InstalledVersion', 'unknown'))}"
        return hashlib.md5(key.encode()).hexdigest()[:12]
    
    def extract_cvss(self, vuln: Dict) -> float:
        """Extract CVSS score from various formats"""
        if 'CVSS' in vuln:
            cvss_data = vuln['CVSS']
            if isinstance(cvss_data, dict):
                for version in ['nvd', 'redhat']:
                    if version in cvss_data:
                        return cvss_data[version].get('V3Score', 0)
        return 0
    
    def deduplicate(self):
        """Remove duplicate vulnerabilities"""
        for severity in self.vulnerabilities:
            seen = set()
            unique = []
            for vuln in self.vulnerabilities[severity]:
                if vuln['id'] not in seen:
                    seen.add(vuln['id'])
                    unique.append(vuln)
            self.vulnerabilities[severity] = unique
    
    def prioritize(self):
        """Prioritize vulnerabilities based on multiple factors"""
        for severity in self.vulnerabilities:
            self.vulnerabilities[severity].sort(
                key=lambda v: (
                    v['severity'] == 'critical',
                    v['cvss_score'],
                    v['exploit'] != 'Not known',
                    not v['patch_available']
                ),
                reverse=True
            )
    
    def calculate_sla(self):
        """Calculate SLA due dates"""
        now = datetime.now()
        sla_map = {
            'critical': self.SLA_CRITICAL,
            'high': self.SLA_HIGH,
            'medium': self.SLA_MEDIUM,
            'low': self.SLA_LOW
        }
        
        for severity, vulns in self.vulnerabilities.items():
            for vuln in vulns:
                sla_hours = sla_map[severity]
                due_date = now + timedelta(hours=sla_hours)
                vuln['sla_due'] = due_date.isoformat()
                vuln['sla_hours'] = sla_hours
    
    def save_results(self):
        """Save processed vulnerabilities to file"""
        with open(self.output_file, 'w') as f:
            json.dump(self.vulnerabilities, f, indent=2)
        print(f"‚úÖ Results saved to {self.output_file}")
    
    def print_summary(self):
        """Print summary of findings"""
        print("\nüìä Vulnerability Summary:")
        print("=" * 50)
        
        total = 0
        for severity, vulns in self.vulnerabilities.items():
            count = len(vulns)
            total += count
            icon = self.get_severity_icon(severity)
            print(f"{icon} {severity.upper()}: {count}")
        
        print(f"\nüìù Total vulnerabilities: {total}")
        
        if self.vulnerabilities['critical']:
            print("\nüö® CRITICAL VULNERABILITIES:")
            for vuln in self.vulnerabilities['critical'][:5]:
                print(f"  - {vuln['title']} ({vuln['package']})")
                print(f"    CVE: {vuln['cve']} | CVSS: {vuln['cvss_score']}")
                print(f"    SLA Due: {vuln['sla_due']}")
    
    @staticmethod
    def get_severity_icon(severity: str) -> str:
        icons = {
            'critical': 'üî¥',
            'high': 'üü†',
            'medium': 'üü°',
            'low': 'üü¢'
        }
        return icons.get(severity, '‚ö™')

def main():
    parser = argparse.ArgumentParser(description='Process vulnerability scan results')
    parser.add_argument('--dependency-results', required=True, help='Snyk JSON results')
    parser.add_argument('--container-results', required=True, help='Trivy JSON results')
    parser.add_argument('--output', default='vulnerabilities.json', help='Output file')
    
    args = parser.parse_args()
    
    processor = VulnerabilityProcessor(
        args.dependency_results,
        args.container_results,
        args.output
    )
    processor.process()

if __name__ == '__main__':
    main()
```

---

## üé´ Automated Ticket Creation

**File:** `scripts/create-vulnerability-tickets.py`

```python
#!/usr/bin/env python3
import json
import os
from jira import JIRA
from datetime import datetime

class TicketCreator:
    def __init__(self):
        self.jira_url = os.getenv('JIRA_BASE_URL')
        self.jira_email = os.getenv('JIRA_USER_EMAIL')
        self.jira_token = os.getenv('JIRA_API_TOKEN')
        
        self.jira = JIRA(
            server=self.jira_url,
            basic_auth=(self.jira_email, self.jira_token)
        )
        
        self.project = 'SEC'
        self.issue_type = 'Bug'
    
    def create_tickets(self, vulnerabilities_file):
        """Create Jira tickets for vulnerabilities"""
        with open(vulnerabilities_file, 'r') as f:
            vulns = json.load(f)
        
        created_count = 0
        
        # Process critical and high severity first
        for severity in ['critical', 'high']:
            for vuln in vulns[severity]:
                if self.should_create_ticket(vuln):
                    ticket = self.create_ticket(vuln, severity)
                    if ticket:
                        print(f"‚úÖ Created ticket: {ticket.key}")
                        created_count += 1
        
        print(f"\nüìù Created {created_count} tickets")
    
    def should_create_ticket(self, vuln):
        """Determine if ticket should be created"""
        # Check if ticket already exists
        jql = f'project = {self.project} AND labels = "vulnerability" AND summary ~ "{vuln["cve"]}"'
        existing = self.jira.search_issues(jql)
        
        return len(existing) == 0
    
    def create_ticket(self, vuln, severity):
        """Create individual Jira ticket"""
        priority = self.map_priority(severity)
        
        description = self.format_description(vuln)
        
        issue_dict = {
            'project': {'key': self.project},
            'summary': f"[{severity.upper()}] {vuln['title']}",
            'description': description,
            'issuetype': {'name': self.issue_type},
            'priority': {'name': priority},
            'labels': ['security', 'vulnerability', 'automated', severity],
            'components': [{'name': 'Security'}],
            'customfield_10001': vuln['cve'],  # CVE ID field
            'customfield_10002': vuln['sla_due'],  # SLA Due Date field
            'duedate': self.format_due_date(vuln['sla_due'])
        }
        
        try:
            issue = self.jira.create_issue(fields=issue_dict)
            
            # Add comment with remediation steps
            self.add_remediation_comment(issue, vuln)
            
            # Assign based on severity
            self.assign_ticket(issue, severity)
            
            return issue
        except Exception as e:
            print(f"‚ùå Failed to create ticket: {e}")
            return None
    
    def format_description(self, vuln):
        """Format ticket description"""
        return f"""
h2. Vulnerability Details

*CVE ID:* {vuln['cve']}
*CVSS Score:* {vuln['cvss_score']}
*Severity:* {vuln['severity'].upper()}
*CWE:* {', '.join(vuln['cwe'])}

h2. Affected Component

*Package:* {vuln['package']}
*Current Version:* {vuln['version']}
*Fixed Version:* {vuln['fixed_version']}
*Type:* {vuln['type']}

h2. Description

{vuln['description']}

h2. Remediation

{self.get_remediation_steps(vuln)}

h2. SLA

*Due Date:* {vuln['sla_due']}
*SLA Hours:* {vuln['sla_hours']}

h2. References

{self.format_references(vuln['references'])}

---
_This ticket was automatically generated by the vulnerability management system._
_Detected at: {vuln['detected_at']}_
        """
    
    def get_remediation_steps(self, vuln):
        """Generate remediation steps"""
        if vuln['patch_available']:
            return f"""
*‚úÖ Patch Available*

1. Update {vuln['package']} to version {vuln['fixed_version']}
2. Run tests to verify functionality
3. Deploy to staging environment
4. Monitor for issues
5. Deploy to production with approval

*Command:*
{{code}}
npm update {vuln['package']}@{vuln['fixed_version']}
{{code}}
            """
        else:
            return """
*‚ö†Ô∏è  No Patch Available*

1. Assess risk and impact
2. Implement workaround or mitigation
3. Consider alternative package
4. Monitor for patch release
5. Document decision in this ticket
            """
    
    def format_references(self, references):
        """Format reference links"""
        if not references:
            return "No references available"
        
        return '\n'.join([f"* [{ref}|{ref}]" for ref in references[:5]])
    
    def format_due_date(self, sla_due):
        """Format due date for Jira"""
        dt = datetime.fromisoformat(sla_due)
        return dt.strftime('%Y-%m-%d')
    
    def add_remediation_comment(self, issue, vuln):
        """Add comment with remediation guidance"""
        comment = f"""
h3. Automated Remediation Guidance

*Priority:* {self.map_priority(vuln['severity'])}
*Exploit Available:* {vuln['exploit']}

{self.get_security_recommendations(vuln)}
        """
        self.jira.add_comment(issue, comment)
    
    def get_security_recommendations(self, vuln):
        """Generate security recommendations"""
        recommendations = []
        
        if vuln['cvss_score'] >= 9.0:
            recommendations.append("üö® *CRITICAL*: Immediate action required. Consider emergency change process.")
        
        if vuln['exploit'] != 'Not known':
            recommendations.append("‚ö†Ô∏è  *Exploit available*: Prioritize remediation. Consider temporary mitigation.")
        
        if not vuln['patch_available']:
            recommendations.append("‚ö†Ô∏è  *No patch*: Implement compensating controls. Consider WAF rules.")
        
        if vuln['type'] == 'container':
            recommendations.append("üê≥ *Container vulnerability*: Rebuild and redeploy container images.")
        
        return '\n'.join(recommendations) if recommendations else "No special recommendations."
    
    def assign_ticket(self, issue, severity):
        """Assign ticket based on severity"""
        assignees = {
            'critical': 'security-lead',
            'high': 'senior-developer',
            'medium': 'developer',
            'low': 'developer'
        }
        
        assignee = assignees.get(severity, 'developer')
        
        try:
            self.jira.assign_issue(issue, assignee)
        except:
            print(f"‚ö†Ô∏è  Could not assign to {assignee}")
    
    @staticmethod
    def map_priority(severity):
        """Map severity to Jira priority"""
        priority_map = {
            'critical': 'Highest',
            'high': 'High',
            'medium': 'Medium',
            'low': 'Low'
        }
        return priority_map.get(severity, 'Medium')

def main():
    creator = TicketCreator()
    creator.create_tickets('vulnerabilities.json')

if __name__ == '__main__':
    main()
```

---

## üìä Vulnerability Dashboard

**File:** `scripts/generate-dashboard.py`

```python
#!/usr/bin/env python3
import json
from datetime import datetime
import matplotlib.pyplot as plt
from collections import Counter

class VulnerabilityDashboard:
    def __init__(self, vulnerabilities_file):
        with open(vulnerabilities_file, 'r') as f:
            self.vulns = json.load(f)
    
    def generate(self):
        """Generate dashboard HTML"""
        html = f"""
<!DOCTYPE html>
<html>
<head>
    <title>Vulnerability Dashboard</title>
    <style>
        body {{ font-family: Arial, sans-serif; margin: 20px; background: #f5f5f5; }}
        .header {{ background: #2c3e50; color: white; padding: 20px; border-radius: 8px; }}
        .stats {{ display: grid; grid-template-columns: repeat(4, 1fr); gap: 20px; margin: 20px 0; }}
        .stat-card {{ background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }}
        .stat-value {{ font-size: 48px; font-weight: bold; }}
        .critical {{ color: #e74c3c; }}
        .high {{ color: #e67e22; }}
        .medium {{ color: #f39c12; }}
        .low {{ color: #27ae60; }}
        .table {{ width: 100%; background: white; border-radius: 8px; overflow: hidden; margin: 20px 0; }}
        table {{ width: 100%; border-collapse: collapse; }}
        th {{ background: #34495e; color: white; padding: 12px; text-align: left; }}
        td {{ padding: 12px; border-bottom: 1px solid #ecf0f1; }}
        tr:hover {{ background: #f8f9fa; }}
        .badge {{ padding: 4px 8px; border-radius: 4px; font-size: 12px; font-weight: bold; }}
    </style>
</head>
<body>
    <div class="header">
        <h1>üõ°Ô∏è Vulnerability Dashboard</h1>
        <p>Last updated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>
    </div>
    
    <div class="stats">
        {self.generate_stats_cards()}
    </div>
    
    <div class="table">
        <h2 style="padding: 20px 20px 0 20px;">Critical Vulnerabilities</h2>
        {self.generate_vulnerability_table('critical')}
    </div>
    
    <div class="table">
        <h2 style="padding: 20px 20px 0 20px;">High Severity Vulnerabilities</h2>
        {self.generate_vulnerability_table('high')}
    </div>
    
    <div style="background: white; padding: 20px; border-radius: 8px; margin: 20px 0;">
        <h2>üìà Metrics</h2>
        {self.generate_metrics()}
    </div>
</body>
</html>
        """
        
        with open('vulnerability-dashboard.html', 'w') as f:
            f.write(html)
        
        print("‚úÖ Dashboard generated: vulnerability-dashboard.html")
    
    def generate_stats_cards(self):
        """Generate statistics cards"""
        cards = []
        colors = {
            'critical': '#e74c3c',
            'high': '#e67e22',
            'medium': '#f39c12',
            'low': '#27ae60'
        }
        
        for severity in ['critical', 'high', 'medium', 'low']:
            count = len(self.vulns[severity])
            color = colors[severity]
            cards.append(f"""
                <div class="stat-card">
                    <div class="stat-value {severity}">{count}</div>
                    <div>{severity.upper()}</div>
                </div>
            """)
        
        return '\n'.join(cards)
    
    def generate_vulnerability_table(self, severity):
        """Generate vulnerability table"""
        vulns = self.vulns[severity][:10]  # Top 10
        
        if not vulns:
            return "<p style='padding: 20px;'>No vulnerabilities found.</p>"
        
        rows = []
        for vuln in vulns:
            patch_status = "‚úÖ Available" if vuln['patch_available'] else "‚ùå Not available"
            rows.append(f"""
                <tr>
                    <td>{vuln['cve']}</td>
                    <td>{vuln['title']}</td>
                    <td>{vuln['package']}</td>
                    <td>{vuln['version']}</td>
                    <td>{vuln['fixed_version']}</td>
                    <td>{vuln['cvss_score']}</td>
                    <td>{patch_status}</td>
                    <td>{vuln['sla_due'][:10]}</td>
                </tr>
            """)
        
        return f"""
            <table>
                <thead>
                    <tr>
                        <th>CVE</th>
                        <th>Title</th>
                        <th>Package</th>
                        <th>Version</th>
                        <th>Fixed In</th>
                        <th>CVSS</th>
                        <th>Patch</th>
                        <th>SLA Due</th>
                    </tr>
                </thead>
                <tbody>
                    {''.join(rows)}
                </tbody>
            </table>
        """
    
    def generate_metrics(self):
        """Generate metrics summary"""
        total = sum(len(v) for v in self.vulns.values())
        with_patch = sum(1 for severity in self.vulns for v in self.vulns[severity] if v['patch_available'])
        
        return f"""
            <ul>
                <li><strong>Total Vulnerabilities:</strong> {total}</li>
                <li><strong>Patches Available:</strong> {with_patch} ({with_patch/total*100:.1f}%)</li>
                <li><strong>Average CVSS:</strong> {self.calculate_average_cvss():.1f}</li>
                <li><strong>Most Affected Package:</strong> {self.get_most_affected_package()}</li>
            </ul>
        """
    
    def calculate_average_cvss(self):
        """Calculate average CVSS score"""
        scores = [v['cvss_score'] for severity in self.vulns for v in self.vulns[severity] if v['cvss_score'] > 0]
        return sum(scores) / len(scores) if scores else 0
    
    def get_most_affected_package(self):
        """Get most affected package"""
        packages = [v['package'] for severity in self.vulns for v in self.vulns[severity]]
        if packages:
            counter = Counter(packages)
            return counter.most_common(1)[0][0]
        return "N/A"

def main():
    dashboard = VulnerabilityDashboard('vulnerabilities.json')
    dashboard.generate()

if __name__ == '__main__':
    main()
```

---

## üîÑ Remediation Workflow

**File:** `remediation-workflow.md`

```markdown
# Vulnerability Remediation Workflow

## 1. Detection ‚Üí Triage (0-2 hours)
- ‚úÖ Automated scan detects vulnerability
- ‚úÖ Severity and CVSS score assigned
- ‚úÖ SLA calculated based on severity
- ‚úÖ Ticket created automatically
- ‚úÖ Security team notified

## 2. Assessment (2-8 hours)
- [ ] Security team reviews details
- [ ] Impact analysis performed
- [ ] Risk assessment completed
- [ ] Priority confirmed or adjusted
- [ ] Assigned to remediation team

## 3. Planning (8-24 hours)
- [ ] Remediation strategy defined
- [ ] Testing plan created
- [ ] Deployment plan approved
- [ ] Resources allocated
- [ ] Stakeholders notified

## 4. Implementation (varies by severity)
**Critical: 24 hours**
- [ ] Patch applied or workaround implemented
- [ ] Unit tests pass
- [ ] Integration tests pass
- [ ] Security scan confirms fix

**High: 72 hours**
- [ ] Fix developed and tested
- [ ] Code review completed
- [ ] Staging deployment successful
- [ ] Monitoring configured

**Medium: 1 week**
- [ ] Fix included in sprint
- [ ] Full test cycle completed
- [ ] Documentation updated

**Low: 30 days**
- [ ] Scheduled for future sprint
- [ ] Backlog prioritization

## 5. Verification (24 hours after fix)
- [ ] Vulnerability rescanned
- [ ] Fix confirmed effective
- [ ] No regression issues
- [ ] Monitoring shows no impact

## 6. Closure
- [ ] Ticket updated with resolution
- [ ] Compliance report updated
- [ ] Lessons learned documented
- [ ] Ticket closed

## Escalation Path

### Critical SLA Breach
1. Notify security lead
2. Escalate to CTO
3. Emergency change approved
4. Deploy outside normal change window

### Blockers
1. Document blocker in ticket
2. Notify security team
3. Implement temporary mitigation
4. Escalate to management if needed
```

---

## üí° Best Practices

1. **Automate Everything** - Scanning, ticketing, notifications
2. **Define Clear SLAs** - Based on severity and risk
3. **Prioritize Effectively** - CVSS score + exploit availability + business impact
4. **Track Metrics** - Time to detect, time to remediate, backlog age
5. **Regular Reporting** - Weekly security dashboards
6. **Continuous Scanning** - Not just at build time
7. **Developer Training** - Secure coding practices
8. **Patch Management** - Regular dependency updates
9. **Risk Acceptance** - Document when patching isn't possible
10. **Compliance** - Maintain audit trail

---

## üéØ Quick Start

```bash
# 1. Run vulnerability scans
./scripts/scan-all.sh

# 2. Process results
python3 scripts/process-vulnerabilities.py \
  --dependency-results snyk-results.json \
  --container-results trivy-results.json

# 3. Create tickets
python3 scripts/create-vulnerability-tickets.py

# 4. Generate dashboard
python3 scripts/generate-dashboard.py

# 5. Open dashboard
open vulnerability-dashboard.html
```
